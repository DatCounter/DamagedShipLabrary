# DamagedShipLibrary Библиотека

Пространство имён: ShipLib
Сборка : ShipLib.dll

*Представляет сущности кораблей в программе.*
**В этой статье**
 - [Определение](#определение)
 - [Интерфейс IShip](#интерфейс-iship)
 - [Перечисление Team](#перечисление-team)
 - [Класс BaseShip](#класс-baseship)
 - [Класс OneDeckedShip](#класс-onedeckedship)
 - [Примеры](#пример-реализации)
---
# Определение
 В структуре библиотеки есть несколько ключевых моментов:
 * Интерфейс [Интерфейс IShip](#интерфейс-iship), который реализует абстрактный класс [BaseShip](#класс-baseship) и наследуется от [IDisposable](https://docs.microsoft.com/ru-ru/dotnet/api/system.idisposable?view=netcore-3.1);
 * Абстрактный класс [BaseShip](#класс-baseship), который реализует дочерние классы кораблей(класс может быть один, а можно его и переопределять, создавая сразу несколько зависимостей. Данный класс гибок, благодаря чему - мы поговорим позже);
 * Публичный класс [OneDeckedShip](#класс-onedeckedship) (однопалубный корабль - в дальнейшем можно его будет переименовать);

Наследование [IDisposable](https://docs.microsoft.com/ru-ru/dotnet/api/system.idisposable?view=netcore-3.1) ---> [IShip](#интерфейс-iship) ---> [BaseShip](#класс-baseship)
             [BaseShip](#класс-baseship) ---> [OneDeckedShip](#класс-onedeckedship)
             [BaseShip](#класс-baseship) ---> .....
             
----------------
# Интерфейс IShip
Пространство имён: ShipLib
Сборка : ShipLib.dll

```C#
public interface IShip
```

## Методы 
|Метод|Описание |
|:---|:---|
| Attack(BaseShip)| Аттакование наследовавших класс BaseShip кораблей, отнимает здоровье, если корабль живой, иначе возвращает ошибку **InvalidOperationException**. Если будет произведена попытка аттаковать союзный корабль, будет типичная ошибка, но с другим значением. Если корабль был уничтожен ранее и очищен с поля боя, то будет ошибка **ObjectDisposedException**. Данный метод аттакует случайным образом исходя из характеристик корабля, у которого есть минимальный урон и максимальный.|

---
# Перечисление Team
Пространство имён: ShipLib
Сборка : ShipLib.dll
Включает в себя две команды:
- Красные
- Синие

Испольуется в [BaseShip](#класс-baseship)
```C#
public enum Team
```

---
# Класс BaseShip
Пространство имён: ShipLib
Сборка : ShipLib.dll
## Описание
Абстрактный класс, реализующее базовое представление дочерних кораблей. Не может быть использован извне, но может реализовать дочерние сущности.
## Свойства
|Свойство|Тип|Описание|
|:---|:---:|:---|
|HitPoints|int|Здоровье коробля, которое устанавливается строго при инициализации|
|Team|Team|Перечисление **(enum)** команд, которое устанавливается строго при инициализации|
|ResultLastAttack|string|Возвращает в строковом представлении процент от нанесённого урона по противнику. Если прошлой атаки не было, возвращает null.|

## Методы
|Метод|Описание|
|:---|:---|
|Attack(BaseShip)|Наследуется от [IShip](#интерфейс-iship). В этом классе выполняется его реализация|
|Dispose()|Обращается к сборщику мусора с целью самоуничтожения. Наследуется от [IDisposable](https://docs.microsoft.com/ru-ru/dotnet/api/system.idisposable?view=netcore-3.1).|
## Конструктор
Определяет стартовое здоровье коробля, его минимальный и максимальный урон и команду.
Если его минимальный урон будет больше максимального, возникнет исключение **ArgumentException**.
```C#
public BaseShip(int HitPoints, int DamageMin, int DamageMax, Team team)
```

---
# Класс OneDeckedShip
Наследуется от BaseShip, производит сокрытие метода Dispose, для того, чтобы экземпляр дочернего класса был самоуничтожен вместе с родительским.

## Конструктор
```C#
public OneDeckedShip(int HitPoints, int DamageMin, int DamageMax, Team Team)
    : base(HitPoints, DamageMin, DamageMax, Team)
    {
        _CountDecked = 1; //may use as k at constr
    }
```
Как видно из конструктора, здесь имеется поле `_CountDecked`, которое можно использовать в конструкторе, следовательно явно определять сколько палубный корабль. При дальнейших реализациях других палуб, изменяется только `_CountDecked` переменная, взятая из родительского класса.
**Следует отметить**, что количество палуб влияет на качество выстрела. Залпы проводятся очередно: из каждой палубы по выстрелу так-же рандомизировано.
## Пример реализации
Создание обычных кораблей(однопалубных)
```C#
OneDeckedShip first = new OneDeckedShip(100, 80, 90, Team.Red);
OneDeckedShip second = new OneDeckedShip(100, 10, 30, Team.Red);
OneDeckedShip third = new OneDeckedShip(100, 10, 30, Team.Blue);
```
Аттакование кораблей
```C#
first.Attack(third);
```
Использование исключений
```C#
try{
    first.Attack(third);
}
catch (InvalidOperationException ex){
    Console.WriteLine("Корабль убит или союзный");
    Console.WriteLine(ex.Message) //or this
}
catch (ObjectDisposedException ex){
    Console.WriteLine("Корабль уплыл ко дну");
    Console.WriteLine(ex.Message); //or this
}
```
Получение процента от нанесенного последнего урона
```C#
if (first.ResultLastAttack != null){
    Console.WriteLine($"Ваш корабль нанёс {ResultLastAttack}% урона!");
}
```
---
Вопросы под вопросом:
* Стоит ли реализовывать все корабли, как отдельным класом(это позволяет гибкость нашего проекта)
* Имеет смысл прописывать некую `k` из `_CountDecked` в конструктор
* Корректная реализация интерфейса IDispose и нужен ли он в проекте
